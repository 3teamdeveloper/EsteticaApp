generator client {
  provider = "prisma-client-js"
 
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  ADMIN           // Acceso total al sistema
  PRESTADOR       // Dueño del negocio
  EMPLEADO        // Profesional que brinda servicios
  RECEPCIONISTA   // Gestiona turnos y clientes
  CLIENTE         // Usuario que solicita servicios
}

model User {
  id           Int           @id @default(autoincrement())
  email        String        @unique
  password     String
  name         String
  username     String        @unique //usado para /[username]
  phone        String?
  businessType String?
  termsAcceptedAt DateTime?
  onboardingCompleted Boolean @default(false)
  role         UserRole      @default(PRESTADOR)
  createdAt    DateTime      @default(now())
  updateAt     DateTime      @updatedAt
  lastInvitationSentAt DateTime?
  services     Service[]
  appointments Appointment[]
  schedules    Schedule[]    // Mantenemos esta relación para gestión del negocio
  publicProfile PublicProfile?
  employees    Employee[]    // empleados que administra (prestador)
  // NUEVO: Relación inversa para la cuenta de empleado
  employeeAccount Employee?  @relation("EmployeeAccount")
  businessHours BusinessHours[] // Horarios de empresa del prestador

  // NUEVOS CAMPOS PARA INVITACIÓN/RESET
  passwordResetToken       String?
  passwordResetTokenExpiry DateTime?

  // CAMPOS PARA TRIAL DE 14 DÍAS Y SUSCRIPCIONES
  trialStartDate           DateTime?
  trialEndDate             DateTime?
  isTrialActive            Boolean   @default(true)
  trialExpirationNotified  Boolean   @default(false)
  
  // DEPRECADO: Mantener por compatibilidad, eliminar después de migrar datos manualmente
  subscriptionType         String?   @default("trial") // 'trial' | 'paid'
  
  // NUEVOS CAMPOS: Separación de estado y tipo de plan
  subscriptionStatus       String?   @default("trial")   // 'trial' | 'active' | 'expired' | 'cancelled'
  subscriptionPlan         String?   @default("free")    // 'free' | 'pro' | 'enterprise'
  subscriptionBilling      String?   @default("monthly") // 'monthly' | 'yearly'
  
  // INFORMACIÓN DE CONTACTO DEL NEGOCIO
  businessPhone            String?
  businessAddress          String?
  businessCity             String?
  businessState            String?
  businessDescription      String?
  businessWebsite          String?
  
  // Relación con tickets de soporte
  supportTickets           SupportTicket[]
  
  // Relación con historial de pagos
  payments                 Payment[]
}

model Client {
  id           Int           @id @default(autoincrement())
  name         String
  email        String?
  phone        String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  appointments Appointment[]

  // @@index([email])
  // @@index([phone])
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

model Appointment {
  id        Int             @id @default(autoincrement())
  date      DateTime
  status    AppointmentStatus
  notes     String?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  // Campos para confirmación por email (48h antes)
  confirmationToken       String?   @unique
  confirmationTokenExpiry DateTime?
  confirmationEmailSentAt DateTime?
  confirmedByClient       Boolean   @default(false)
  confirmationMethod      String?   // 'manual' | 'email_link' | 'auto'

  //relaciones 
  service   Service         @relation(fields: [serviceId], references: [id], map: "AppointmentToService")
  serviceId Int

  user   User   @relation(fields: [userId], references: [id], map: "AppointmentToUser") //prestador 
  userId Int

  client   Client? @relation(fields: [clientId], references: [id], map: "AppointmentToClient")
  clientId Int?

  employee   Employee? @relation(fields: [employeeId], references: [id], map: "AppointmentToEmployee")
  employeeId Int?

  // @@index([date])
  // @@index([status])
}

model Service {
  id          Int           @id @default(autoincrement())
  name        String
  duration    Int //en minutos
  price       Float
  description String?
  serviceImage String?
  isActive    Boolean       @default(true)
  deleted     Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  user   User   @relation(fields: [userId], references: [id], map: "ServiceToUser")
  userId Int

  appointments Appointment[]
  schedules    Schedule[]
  employees    EmployeeService[]
  roundRobinTracking RoundRobinTracking[]

  // @@index([name])
}

model Schedule {
  id        Int     @id @default(autoincrement())
  dayOfWeek Int     //0 (Domingo) - 6 (Sabado)
  period    Int     @default(1) // 1 = primer período, 2 = segundo período
  startTime String  //"09:00"
  endTime   String  // "17:00"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], map: "ScheduleToUser")
  userId    Int

  employee   Employee @relation(fields: [employeeId], references: [id], map: "ScheduleToEmployee")
  employeeId Int

  service   Service @relation(fields: [serviceId], references: [id], map: "ScheduleToService")
  serviceId Int

  // @@index([dayOfWeek])
  // @@unique([employeeId, dayOfWeek, serviceId, period])
}

model PublicProfile {
  id            Int      @id @default(autoincrement())
  urlName       String   @unique // URL amigable para el perfil público
  pageTitle     String?  // Título de la página que se muestra en el H1 (separado del urlName)
  bio           String?
  coverImage    String?
  profileImage  String?
  publicLinks   Json?    // Array de objetos {name, url}
  // Personalización de mini landing
  fontFamily            String?
  backgroundColor       String?
  cardBackgroundColor   String?
  primaryColor          String?
  textColor             String?
  slogan                String?
  layoutVariant         String? // 'signature' | 'split' | 'minimal' | 'gallery'
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id])
  userId        Int      @unique
}

model BusinessHours {
  id        Int     @id @default(autoincrement())
  dayOfWeek Int     //0 (Domingo) - 6 (Sabado)
  startTime String  //"09:00"
  endTime   String  // "17:00"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], map: "BusinessHoursToUser")
  userId    Int

  // @@index([dayOfWeek])
}

// Nuevos modelos para soporte multi-empleado
model Employee {
  id        Int           @id @default(autoincrement())
  name      String
  email     String?
  phone     String?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  employeeImage String?

  // Relaciones
  user      User          @relation(fields: [userId], references: [id], map: "EmployeeToUser")
  userId    Int

  // NUEVO: Relación con la cuenta User del empleado
  accountUserId Int?      @unique // <- este es el User.id del empleado (puede ser null para empleados sin cuenta)
  accountUser   User?     @relation("EmployeeAccount", fields: [accountUserId], references: [id])

  services  EmployeeService[]
  schedules Schedule[]
  appointments Appointment[]
}

model EmployeeService {
  id        Int       @id @default(autoincrement())
  createdAt DateTime  @default(now())

  // Relaciones
  employee  Employee  @relation(fields: [employeeId], references: [id], map: "EmployeeServiceToEmployee")
  employeeId Int

  service   Service   @relation(fields: [serviceId], references: [id], map: "EmployeeServiceToService")
  serviceId Int

  @@unique([employeeId, serviceId])
}

// Modelo para tracking de Round Robin
model RoundRobinTracking {
  id        Int      @id @default(autoincrement())
  serviceId Int
  date      DateTime @db.Date
  timeSlot  String   // "09:00", "10:00", etc.
  lastIndex Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  service Service @relation(fields: [serviceId], references: [id])

  @@unique([serviceId, date, timeSlot])
}

// Modelo para tickets de soporte técnico
model SupportTicket {
  id          Int      @id @default(autoincrement())
  subject     String
  message     String   @db.Text
  priority    String   @default("MEDIUM") // LOW, MEDIUM, HIGH, URGENT
  status      String   @default("OPEN")   // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  category    String?  // TECHNICAL, BILLING, FEATURE_REQUEST, BUG_REPORT, OTHER
  
  // Información del usuario
  userEmail   String
  userName    String
  userPhone   String?
  businessName String?
  
  // Información técnica adicional
  browserInfo String?
  deviceInfo  String?
  errorDetails String? @db.Text
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  resolvedAt  DateTime?
  
  // Relación con el usuario (opcional, por si el usuario está logueado)
  user        User?    @relation(fields: [userId], references: [id])
  userId      Int?
}

// Modelo para historial de pagos de suscripciones
model Payment {
  id                  Int      @id @default(autoincrement())
  userId              Int
  
  // Información de Mercado Pago
  mpPaymentId         String   @unique
  mpPreferenceId      String?
  status              String   // 'approved', 'pending', 'rejected', 'refunded'
  statusDetail        String?
  
  // Montos
  amount              Float
  currency            String   @default("ARS")
  
  // Tipo de pago y plan
  paymentType         String?  // 'initial', 'renewal', 'upgrade', 'downgrade'
  planType            String?  // 'pro', 'enterprise' - Qué plan se pagó
  billingType         String?  // 'monthly', 'yearly' - Tipo de facturación
  
  // Metadata
  paymentMethod       String?
  
  // Fechas
  approvedAt          DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  // Relación
  user                User     @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([mpPaymentId])
}
